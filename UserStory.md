## 1. Общая архитектура системы

В системе используются следующие компоненты:

* **Client (Пользователь)** — инициирует пользовательские действия.
* **API Gateway** — единая точка входа, маршрутизирует запросы к внутренним сервисам.
* **Orders Service** — сервис управления заказами.
* **Payments Service** — сервис управления пользовательскими счетами и платежами.
* **Message Queue (MQ)** — брокер сообщений для асинхронного взаимодействия сервисов.

Взаимодействие между сервисами Orders Service и Payments Service осуществляется асинхронно через очередь сообщений с использованием паттернов **Transactional Outbox** и **Transactional Inbox**.

---

## 2. Payments Service — пользовательские сценарии

Payments Service предоставляет следующие возможности:

1. Создание счета пользователя по `user_id`.
2. Пополнение счета пользователя на заданную сумму.
3. Получение текущего баланса счета.

Ограничения:

* Предполагается, что у одного пользователя может существовать **не более одного счета**.

---

## 3. Orders Service — пользовательские сценарии

Orders Service предоставляет следующие возможности:

1. Создание нового заказа.
2. Получение списка заказов пользователя.
3. Получение статуса конкретного заказа.

### Модель данных заказа

```
Order:
- id
- user_id
- amount
- description
- status
```

Допустимые значения `status`:

* `NEW` — сразу после создания заказа.
* `FINISHED` — оплата заказа завершена успешно.
* `CANCELED` — оплата заказа завершилась неуспешно.

---

## 4. Ключевой сценарий системы

### Создание заказа с автоматической оплатой

#### Шаг 1. Создание заказа

Пользователь отправляет запрос на создание нового заказа через API Gateway.

Orders Service:

* В рамках **одной транзакции БД**:

  * создает запись нового заказа со статусом `NEW`;
  * создает задачу на оплату заказа в **Transactional Outbox** (часть 1).

---

#### Шаг 2. Публикация задачи на оплату

Orders Service:

* Асинхронно вычитывает задачу из Transactional Outbox;
* Отправляет сообщение в Message Queue (Transactional Outbox — часть 2).

---

#### Шаг 3. Прием задачи на оплату

Payments Service:

* Получает сообщение из Message Queue;
* Сохраняет задачу на оплату в свою базу данных (Transactional Inbox — часть 1).

---

#### Шаг 4. Выполнение оплаты

Payments Service:

* Выполняет задачу на оплату (Transactional Inbox — часть 2);
* В рамках одной транзакции:

  * выполняет бизнес-логику списания средств;
  * сохраняет задачу на отправку события о результате оплаты в Transactional Outbox (часть 1).

Варианты исхода:

* Если счет пользователя не найден — формируется событие **ошибки оплаты**.
* Если на счете недостаточно средств — формируется событие **ошибки оплаты**.
* Если списание прошло успешно — формируется событие **успешной оплаты**.

---

#### Шаг 5. Публикация события об оплате

Payments Service:

* Асинхронно вычитывает событие из Transactional Outbox;
* Отправляет событие о результате оплаты в Message Queue (Transactional Outbox — часть 2).

---

#### Шаг 6. Обновление статуса заказа

Orders Service:

* Получает событие об успешной или неуспешной оплате из Message Queue;
* Обновляет статус соответствующего заказа:

  * `FINISHED` — при успешной оплате;
  * `CANCELED` — при неуспешной оплате.

Примечание:

* Transactional Inbox может не использоваться, так как операции обновления статуса заказа являются **идемпотентными**.

---

## 5. Нефункциональные требования (implicit из схемы)

* Асинхронная обработка операций оплаты.
* Гарантия доставки сообщений (at-least-once).
* Консистентность данных между сервисами через паттерны Transactional Outbox / Inbox.
* Отсутствие распределенных транзакций между сервисами.
